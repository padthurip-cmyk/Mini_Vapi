<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Voice Bridge</title>
    <style>
        :root { --bg: #0a0a0f; --bg2: #12121a; --bg3: #1a1a25; --accent: #00d4aa; --text: #fff; --text2: #8b8b9e; --border: #2a2a3a; --danger: #ff6b6b; --warning: #ffd93d; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
        body.compact .full { display: none; }
        body.compact .widget { display: flex; }
        
        .widget { display: none; position: fixed; bottom: 20px; right: 20px; background: var(--bg2); border: 1px solid var(--border); border-radius: 14px; padding: 12px 16px; align-items: center; gap: 12px; cursor: pointer; z-index: 9999; min-width: 200px; }
        .widget:hover { border-color: var(--accent); }
        .widget.listening { border-color: var(--accent); box-shadow: 0 0 20px rgba(0,212,170,0.3); }
        .widget.active { border-color: var(--warning); }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--text2); }
        .dot.listening { background: var(--accent); animation: pulse 2s infinite; }
        .dot.active { background: var(--warning); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; transform: scale(1.2); } }
        .widget-text { flex: 1; font-size: 14px; }
        
        .controls { display: none; position: fixed; bottom: 75px; right: 20px; background: var(--bg2); border: 1px solid var(--border); border-radius: 10px; padding: 8px; z-index: 9998; }
        .controls.show { display: flex; flex-direction: column; gap: 4px; }
        .controls button { background: var(--bg3); border: none; padding: 10px 14px; color: var(--text); border-radius: 6px; cursor: pointer; font-size: 13px; text-align: left; }
        .controls button:hover { background: var(--bg); }
        
        .full { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 16px 0; border-bottom: 1px solid var(--border); margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .logo { font-size: 20px; font-weight: 700; }
        .logo span { color: var(--accent); }
        .header-btns { display: flex; gap: 8px; }
        .btn { background: var(--bg2); border: 1px solid var(--border); padding: 10px 16px; color: var(--text); border-radius: 8px; cursor: pointer; font-size: 14px; }
        .btn:hover { border-color: var(--accent); }
        .btn.primary { background: var(--accent); border-color: var(--accent); color: var(--bg); }
        .btn.danger { background: var(--danger); border-color: var(--danger); color: var(--bg); }
        
        .status { background: var(--bg2); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; display: flex; align-items: center; gap: 16px; }
        .status.listening { border-color: var(--accent); }
        .status.active { border-color: var(--warning); animation: glow 2s infinite; }
        @keyframes glow { 50% { box-shadow: 0 0 20px rgba(255, 217, 61, 0.3); } }
        .status-icon { width: 48px; height: 48px; background: var(--bg3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .status-title { font-size: 18px; font-weight: 600; }
        .status-sub { color: var(--text2); margin-top: 4px; }
        .badge { background: var(--bg3); padding: 2px 8px; border-radius: 4px; color: var(--accent); font-family: monospace; }
        
        .card { background: var(--bg2); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px; }
        .card-title { font-size: 12px; color: var(--text2); text-transform: uppercase; margin-bottom: 12px; }
        .row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); }
        .row:last-child { border: none; }
        .row-label { color: var(--text2); }
        .row-value { font-family: monospace; }
        .row-value.ok { color: var(--accent); }
        .row-value.warn { color: var(--warning); }
        .row-value.err { color: var(--danger); }
        
        .live-transcript { background: var(--bg3); border: 2px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px; min-height: 80px; transition: all 0.3s; }
        .live-transcript.hearing { border-color: var(--accent); box-shadow: 0 0 15px rgba(0, 212, 170, 0.3); }
        .live-transcript.wake { border-color: var(--warning); box-shadow: 0 0 20px rgba(255, 217, 61, 0.4); }
        .live-transcript-label { font-size: 11px; color: var(--text2); text-transform: uppercase; margin-bottom: 8px; }
        .live-transcript-text { font-size: 18px; color: var(--text); min-height: 28px; line-height: 1.4; }
        .live-transcript-text.placeholder { color: var(--text2); font-style: italic; font-size: 14px; }
        .wake-detected { background: var(--warning); color: var(--bg); padding: 2px 8px; border-radius: 4px; font-weight: bold; }
        
        .input-group { margin-bottom: 14px; }
        .input-group label { display: block; font-size: 13px; color: var(--text2); margin-bottom: 6px; }
        .input-group input { width: 100%; background: var(--bg3); border: 1px solid var(--border); padding: 10px 12px; color: var(--text); border-radius: 6px; font-family: monospace; font-size: 14px; }
        .input-group input:focus { outline: none; border-color: var(--accent); }
        .settings-btns { display: flex; gap: 10px; margin-top: 16px; flex-wrap: wrap; }
        
        .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(50px); background: var(--bg2); border: 1px solid var(--border); padding: 12px 20px; border-radius: 10px; opacity: 0; transition: all 0.3s; z-index: 10000; font-size: 14px; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        .toast.error { border-color: var(--danger); background: rgba(255,107,107,0.1); }
        .toast.success { border-color: var(--accent); background: rgba(0,212,170,0.1); }
        
        .log { background: var(--bg3); border-radius: 8px; padding: 12px; margin-top: 16px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 11px; color: var(--text2); }
        .log-entry { padding: 3px 0; border-bottom: 1px solid var(--border); word-break: break-all; }
        .log-entry:last-child { border: none; }
        .log-entry.error { color: var(--danger); }
        .log-entry.success { color: var(--accent); }
        
        /* Call active overlay */
        .call-active-banner {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, var(--warning), #ff9f43);
            color: var(--bg);
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
            z-index: 10001;
            animation: slideDown 0.3s ease;
        }
        .call-active-banner.show { display: block; }
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        
        @media (max-width: 500px) {
            .header { flex-direction: column; text-align: center; }
            .status { flex-direction: column; text-align: center; }
            .widget { left: 20px; min-width: auto; }
            .controls { left: 20px; }
        }
    </style>
</head>
<body>
    <!-- Call Active Banner -->
    <div class="call-active-banner" id="callBanner">
        üó£Ô∏è Call Active - Speak to your assistant | <button onclick="endCall()" style="background:var(--bg);color:var(--text);border:none;padding:4px 12px;border-radius:4px;cursor:pointer;margin-left:10px;">End Call</button>
    </div>

    <div class="widget" id="widget" onclick="toggleControls(event)">
        <div class="dot" id="wDot"></div>
        <div class="widget-text" id="wText">Starting...</div>
        <span>‚öôÔ∏è</span>
    </div>
    <div class="controls" id="controls">
        <button onclick="expand()">üî≤ Open Interface</button>
        <button id="cToggle" onclick="toggle()">‚è∏Ô∏è Pause</button>
        <button onclick="endCall()">‚èπÔ∏è End Call</button>
        <button onclick="manualCall()">üìû Manual Call</button>
    </div>

    <div class="full">
        <div class="header">
            <div class="logo">üéôÔ∏è Voice <span>Bridge</span></div>
            <div class="header-btns">
                <button class="btn" onclick="minimize()">üìå Minimize</button>
                <button class="btn primary" id="mainBtn" onclick="toggle()">üëÇ Start</button>
            </div>
        </div>

        <div class="status" id="status">
            <div class="status-icon" id="icon">üé§</div>
            <div>
                <div class="status-title" id="title">Initializing...</div>
                <div class="status-sub" id="sub">Please wait</div>
            </div>
        </div>

        <div class="live-transcript" id="liveTranscript">
            <div class="live-transcript-label">üé§ Live Transcript</div>
            <div class="live-transcript-text placeholder" id="liveText">Speak to see your words here...</div>
        </div>

        <div class="card">
            <div class="card-title">System Status</div>
            <div class="row"><span class="row-label">Speech Recognition</span><span class="row-value" id="sSpeech">...</span></div>
            <div class="row"><span class="row-label">Vapi SDK</span><span class="row-value" id="sVapi">Loading...</span></div>
            <div class="row"><span class="row-label">Microphone</span><span class="row-value" id="sMic">...</span></div>
            <div class="row"><span class="row-label">Call Status</span><span class="row-value" id="sCall">Idle</span></div>
            <div class="row"><span class="row-label">Sessions</span><span class="row-value" id="sSessions">0</span></div>
        </div>

        <div class="card">
            <div class="card-title">Configuration</div>
            <div class="input-group">
                <label>Wake Word (what you say to activate)</label>
                <input id="inWake" value="hey mini" placeholder="hey mini">
            </div>
            <div class="input-group">
                <label>Vapi Public Key</label>
                <input id="inKey" placeholder="pk_xxxxxxxx" type="password">
            </div>
            <div class="input-group">
                <label>Assistant ID</label>
                <input id="inAssist" placeholder="your-assistant-id">
            </div>
            <div class="settings-btns">
                <button class="btn primary" onclick="save()">üíæ Save</button>
                <button class="btn" onclick="testMic()">üé§ Test Mic</button>
                <button class="btn" onclick="manualCall()">üìû Test Call</button>
                <button class="btn" onclick="forceRestart()">üîÑ Restart</button>
            </div>
            
            <div class="log" id="log"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
    // =====================================================
    // CONFIGURATION
    // =====================================================
    const CONFIG = { 
        wake: 'hey mini', 
        key: '', 
        assist: '', 
        debounce: 1500,  // Reduced for faster response
        sensitivity: 0.6  // Wake word match sensitivity
    };
    
    const state = { 
        listening: false, 
        calling: false, 
        rec: null, 
        vapi: null, 
        vapiOk: false,
        vapiClass: null,
        sessions: 0, 
        lastWake: 0, 
        restartTimer: null,
        abortCount: 0,
        maxAborts: 5,
        interimTranscript: '',
        finalTranscript: ''
    };

    // Multiple CDN sources
    const VAPI_SDK_URLS = [
        'https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js',
        'https://unpkg.com/@vapi-ai/web@latest/dist/vapi.umd.js',
        'https://cdn.jsdelivr.net/npm/@vapi-ai/web@latest/dist/vapi.umd.js'
    ];

    // =====================================================
    // LOGGING
    // =====================================================
    function log(msg, type = '') {
        console.log(`[${type || 'info'}] ${msg}`);
        const logEl = document.getElementById('log');
        if (!logEl) return;
        const entry = document.createElement('div');
        entry.className = 'log-entry ' + type;
        entry.textContent = `${new Date().toLocaleTimeString()} - ${msg}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
        while (logEl.children.length > 40) logEl.removeChild(logEl.firstChild);
    }

    function updateLiveTranscript(text, isWakeWord = false) {
        const container = document.getElementById('liveTranscript');
        const textEl = document.getElementById('liveText');
        
        if (text && text.trim()) {
            container.classList.add('hearing');
            container.classList.toggle('wake', isWakeWord);
            textEl.classList.remove('placeholder');
            
            if (isWakeWord) {
                const regex = new RegExp(`(${CONFIG.wake})`, 'gi');
                textEl.innerHTML = text.replace(regex, '<span class="wake-detected">$1</span>');
            } else {
                textEl.textContent = text;
            }
        } else {
            textEl.textContent = 'Speak to see your words here...';
            textEl.classList.add('placeholder');
            container.classList.remove('hearing', 'wake');
        }
    }

    // =====================================================
    // VAPI SDK LOADER
    // =====================================================
    function loadScript(url, timeout = 10000) {
        return new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;
            
            const timer = setTimeout(() => {
                script.remove();
                resolve(false);
            }, timeout);
            
            script.onload = () => {
                clearTimeout(timer);
                resolve(true);
            };
            
            script.onerror = () => {
                clearTimeout(timer);
                script.remove();
                resolve(false);
            };
            
            document.head.appendChild(script);
        });
    }

    function getVapiClass() {
        if (typeof Vapi !== 'undefined' && typeof Vapi === 'function') return { type: 'class', cls: Vapi };
        if (window.Vapi && typeof window.Vapi === 'function') return { type: 'class', cls: window.Vapi };
        if (window.vapiSDK && window.vapiSDK.run) return { type: 'html', cls: window.vapiSDK };
        if (window.Vapi && window.Vapi.default) return { type: 'class', cls: window.Vapi.default };
        return null;
    }

    async function loadVapiSDK() {
        setStatus('sVapi', 'Loading...', 'warn');
        
        for (let i = 0; i < VAPI_SDK_URLS.length; i++) {
            const url = VAPI_SDK_URLS[i];
            log(`Loading SDK ${i + 1}/${VAPI_SDK_URLS.length}...`);
            
            const loaded = await loadScript(url, 8000);
            
            if (loaded) {
                await new Promise(r => setTimeout(r, 500));
                const result = getVapiClass();
                if (result) {
                    log(`‚úì SDK loaded (${result.type})`, 'success');
                    setStatus('sVapi', 'Loaded', 'ok');
                    state.vapiClass = result;
                    return result;
                }
            }
        }
        
        log('All SDK sources failed', 'error');
        setStatus('sVapi', 'Failed', 'err');
        return null;
    }

    // =====================================================
    // INITIALIZATION
    // =====================================================
    document.addEventListener('DOMContentLoaded', async () => {
        log('=== Voice Bridge v5 ===');
        
        loadConfig();
        checkSpeech();
        
        const vapiResult = await loadVapiSDK();
        
        if (vapiResult && CONFIG.key) {
            initVapi();
        } else if (vapiResult) {
            log('‚ö†Ô∏è Add Vapi credentials in settings');
            setStatus('sVapi', 'Need Config', 'warn');
        }
        
        initRecognition();
        await checkMic();
        
        document.body.classList.add('compact');
        updateUI('idle', 'Ready', `Say <span class="badge">${CONFIG.wake}</span>`);
        
        // Request microphone permission upfront
        try {
            await navigator.mediaDevices.getUserMedia({ audio: true });
            log('‚úì Microphone access granted', 'success');
        } catch (e) {
            log('Microphone permission needed', 'warn');
        }
        
        setTimeout(() => { 
            if (state.rec && !state.calling) startListening();
        }, 1000);
    });

    // =====================================================
    // CONFIG
    // =====================================================
    function loadConfig() {
        try {
            const s = localStorage.getItem('voiceBridgeConfig');
            if (s) Object.assign(CONFIG, JSON.parse(s));
        } catch (e) {}
        document.getElementById('inWake').value = CONFIG.wake;
        document.getElementById('inKey').value = CONFIG.key;
        document.getElementById('inAssist').value = CONFIG.assist;
    }

    function save() {
        CONFIG.wake = document.getElementById('inWake').value.toLowerCase().trim() || 'hey mini';
        CONFIG.key = document.getElementById('inKey').value.trim();
        CONFIG.assist = document.getElementById('inAssist').value.trim();
        
        try { localStorage.setItem('voiceBridgeConfig', JSON.stringify(CONFIG)); } catch (e) {}
        
        if (state.vapiClass && CONFIG.key) {
            initVapi();
        }
        
        toast('‚úì Saved!', 'success');
        log('Config saved');
        
        if (state.listening) { 
            stopListening();
            setTimeout(startListening, 500);
        }
    }

    // =====================================================
    // CHECKS
    // =====================================================
    function checkSpeech() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        setStatus('sSpeech', SR ? 'Supported' : 'Not Supported', SR ? 'ok' : 'err');
        return !!SR;
    }

    async function checkMic() {
        try {
            const r = await navigator.permissions.query({ name: 'microphone' });
            setStatus('sMic', r.state === 'granted' ? 'Allowed' : r.state === 'denied' ? 'Blocked' : 'Prompt', 
                     r.state === 'granted' ? 'ok' : r.state === 'denied' ? 'err' : 'warn');
        } catch (e) { 
            setStatus('sMic', 'Unknown', 'warn'); 
        }
    }

    // =====================================================
    // ENHANCED SPEECH RECOGNITION
    // =====================================================
    function initRecognition() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
            log('Speech Recognition not supported', 'error');
            return;
        }
        
        state.rec = new SR();
        
        // Optimized settings for better accuracy
        state.rec.continuous = true;
        state.rec.interimResults = true;
        state.rec.maxAlternatives = 3;  // Get multiple alternatives for better matching
        state.rec.lang = 'en-US';

        state.rec.onstart = () => {
            state.listening = true;
            state.abortCount = 0;
            state.interimTranscript = '';
            state.finalTranscript = '';
            updateUI('listening');
            updateBtns(true);
            setStatus('sMic', 'Listening', 'ok');
            log('üé§ Listening for wake word...');
        };

        state.rec.onresult = (event) => {
            if (state.calling) return;
            
            state.interimTranscript = '';
            
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const result = event.results[i];
                const transcript = result[0].transcript;
                
                if (result.isFinal) {
                    state.finalTranscript = transcript;
                    log(`Final: "${transcript}"`);
                } else {
                    state.interimTranscript = transcript;
                }
                
                // Check all alternatives for wake word (better matching)
                for (let j = 0; j < result.length; j++) {
                    const alt = result[j].transcript.toLowerCase().trim();
                    if (checkWakeWord(alt)) {
                        return;  // Wake word found
                    }
                }
            }
            
            // Update display with current transcript
            const displayText = state.finalTranscript || state.interimTranscript;
            const hasWake = displayText.toLowerCase().includes(CONFIG.wake.toLowerCase());
            updateLiveTranscript(displayText, hasWake);
        };

        state.rec.onerror = (e) => {
            if (e.error === 'not-allowed') {
                setStatus('sMic', 'Blocked', 'err');
                state.listening = false;
                updateBtns(false);
                log('‚ùå Microphone blocked!', 'error');
                toast('Please allow microphone access', 'error');
            } else if (e.error === 'aborted') {
                state.abortCount++;
                const delay = state.abortCount >= state.maxAborts ? 3000 : 500;
                if (state.abortCount >= state.maxAborts) {
                    state.abortCount = 0;
                    log('Resetting after multiple aborts');
                }
                scheduleRestart(delay);
            } else if (e.error === 'no-speech') {
                // Normal - just continue
                scheduleRestart(100);
            } else if (e.error === 'network') {
                log('Network error - retrying', 'warn');
                scheduleRestart(2000);
            } else {
                log(`Error: ${e.error}`, 'error');
                scheduleRestart(1000);
            }
        };

        state.rec.onend = () => {
            if (state.listening && !state.calling) {
                scheduleRestart(100);
            }
        };
        
        log('‚úì Speech recognition ready');
    }

    // Improved wake word detection with fuzzy matching
    function checkWakeWord(transcript) {
        const wake = CONFIG.wake.toLowerCase().trim();
        const text = transcript.toLowerCase().trim();
        
        // Direct match
        if (text.includes(wake)) {
            triggerWake(transcript);
            return true;
        }
        
        // Fuzzy match for similar sounding words
        const wakeWords = wake.split(' ');
        const textWords = text.split(' ');
        
        let matchCount = 0;
        for (const wakeWord of wakeWords) {
            for (const textWord of textWords) {
                if (isSimilar(wakeWord, textWord)) {
                    matchCount++;
                    break;
                }
            }
        }
        
        // If most words match, trigger
        if (matchCount >= wakeWords.length * CONFIG.sensitivity) {
            triggerWake(transcript);
            return true;
        }
        
        return false;
    }

    // Simple similarity check for fuzzy matching
    function isSimilar(a, b) {
        if (a === b) return true;
        if (Math.abs(a.length - b.length) > 2) return false;
        
        // Check if one contains the other
        if (a.includes(b) || b.includes(a)) return true;
        
        // Simple Levenshtein-like check
        let matches = 0;
        const shorter = a.length < b.length ? a : b;
        const longer = a.length < b.length ? b : a;
        
        for (let i = 0; i < shorter.length; i++) {
            if (longer.includes(shorter[i])) matches++;
        }
        
        return matches / shorter.length > 0.7;
    }

    function triggerWake(transcript) {
        const now = Date.now();
        if (now - state.lastWake < CONFIG.debounce) {
            log('Wake debounced');
            return;
        }
        
        state.lastWake = now;
        log(`üéØ WAKE WORD DETECTED: "${transcript}"`, 'success');
        updateLiveTranscript(transcript, true);
        onWakeDetected();
    }

    function scheduleRestart(delay = 500) {
        if (state.restartTimer) clearTimeout(state.restartTimer);
        state.restartTimer = setTimeout(() => {
            if (state.listening && !state.calling && state.rec) {
                try { state.rec.start(); } catch (e) {}
            }
        }, delay);
    }

    function startListening() {
        if (!state.rec || state.calling) return;
        state.listening = true;
        state.abortCount = 0;
        try {
            state.rec.start();
        } catch (e) {
            if (!e.message.includes('already started')) {
                log(`Start error: ${e.message}`, 'error');
            }
        }
    }

    function stopListening() {
        state.listening = false;
        if (state.restartTimer) clearTimeout(state.restartTimer);
        try { if (state.rec) state.rec.stop(); } catch (e) {}
        if (!state.calling) updateUI('idle');
        updateBtns(false);
    }

    function toggle() { state.listening ? stopListening() : startListening(); }

    function forceRestart() {
        log('Force restarting...');
        stopListening();
        if (state.vapi && state.calling) {
            try { state.vapi.stop(); } catch(e) {}
        }
        state.calling = false;
        state.abortCount = 0;
        document.getElementById('callBanner').classList.remove('show');
        setTimeout(() => {
            initVapi();
            startListening();
        }, 1000);
        toast('Restarted', 'success');
    }

    // =====================================================
    // VAPI - Auto-start calls without manual tap
    // =====================================================
    function initVapi() {
        if (!state.vapiClass || !CONFIG.key) {
            log('Vapi not configured');
            return;
        }
        
        try {
            if (state.vapiClass.type === 'class') {
                state.vapi = new state.vapiClass.cls(CONFIG.key);
                setupVapiEvents();
                state.vapiOk = true;
                setStatus('sVapi', 'Ready', 'ok');
                log('‚úì Vapi initialized', 'success');
            } else if (state.vapiClass.type === 'html') {
                state.vapiOk = true;
                setStatus('sVapi', 'Ready', 'ok');
                log('‚úì Vapi HTML SDK ready', 'success');
            }
        } catch (e) {
            log(`Vapi init error: ${e.message}`, 'error');
            state.vapiOk = false;
            setStatus('sVapi', 'Error', 'err');
        }
    }

    function setupVapiEvents() {
        if (!state.vapi) return;
        
        state.vapi.on('call-start', () => {
            state.calling = true;
            state.sessions++;
            document.getElementById('sSessions').textContent = state.sessions;
            document.getElementById('callBanner').classList.add('show');
            setStatus('sCall', 'Connected', 'ok');
            updateUI('active', 'üìû Call Active', 'Speak to your assistant');
            log('üìû Call connected!', 'success');
            toast('Connected! Speak now.', 'success');
        });

        state.vapi.on('call-end', () => {
            log('Call ended');
            state.calling = false;
            document.getElementById('callBanner').classList.remove('show');
            setStatus('sCall', 'Ended', 'warn');
            updateUI('idle');
            updateLiveTranscript('');
            
            // Reinitialize and restart listening
            setTimeout(() => {
                initVapi();
                setStatus('sCall', 'Idle', '');
                startListening();
            }, 2000);
        });

        state.vapi.on('speech-start', () => {
            log('üó£Ô∏è You are speaking...');
        });

        state.vapi.on('speech-end', () => {
            log('Listening...');
        });

        state.vapi.on('message', (msg) => {
            if (msg.type === 'transcript') {
                const role = msg.role === 'assistant' ? 'ü§ñ' : 'üë§';
                log(`${role}: ${msg.transcript}`);
            }
        });

        state.vapi.on('error', (err) => {
            const errMsg = err?.message || err?.error?.message || JSON.stringify(err);
            log(`Vapi error: ${errMsg}`, 'error');
            state.calling = false;
            document.getElementById('callBanner').classList.remove('show');
            setStatus('sCall', 'Error', 'err');
            updateUI('idle');
            toast('Call error - retrying...', 'error');
            
            setTimeout(() => {
                initVapi();
                startListening();
            }, 3000);
        });
    }

    function onWakeDetected() {
        // Play activation sound
        playSound();
        
        // Stop wake word listening
        stopListening();
        
        // Update UI
        updateUI('active', 'üéØ Wake Detected!', 'Starting call...');
        setStatus('sCall', 'Connecting...', 'warn');

        // Validate configuration
        if (!state.vapiOk) {
            toast('Vapi SDK not loaded', 'error');
            log('Vapi not ready', 'error');
            setTimeout(startListening, 2000);
            return;
        }
        
        if (!CONFIG.key) {
            toast('Add Vapi Public Key in settings', 'error');
            setTimeout(startListening, 2000);
            return;
        }
        
        if (!CONFIG.assist) {
            toast('Add Assistant ID in settings', 'error');
            setTimeout(startListening, 2000);
            return;
        }

        // START THE CALL AUTOMATICALLY
        startVapiCall();
    }

    function startVapiCall() {
        try {
            log('üöÄ Starting Vapi call...', 'success');
            
            if (state.vapiClass.type === 'html') {
                // HTML SDK
                state.vapi = state.vapiClass.cls.run({
                    apiKey: CONFIG.key,
                    assistant: CONFIG.assist,
                    config: { 
                        hideButton: true,
                        position: 'bottom-right'
                    }
                });
                
                if (state.vapi) {
                    setupVapiEvents();
                    state.vapi.start();
                }
            } else {
                // Class SDK - direct start
                state.vapi.start(CONFIG.assist);
            }
            
        } catch (e) {
            log(`Call start failed: ${e.message}`, 'error');
            toast('Failed to start call', 'error');
            setStatus('sCall', 'Failed', 'err');
            setTimeout(startListening, 3000);
        }
    }

    // Manual call for testing
    function manualCall() {
        if (state.calling) {
            toast('Call already active', 'warn');
            return;
        }
        
        if (!CONFIG.key || !CONFIG.assist) {
            toast('Configure Vapi credentials first', 'error');
            return;
        }
        
        log('Manual call triggered');
        onWakeDetected();
    }

    function endCall() {
        if (state.vapi) {
            try { 
                state.vapi.stop(); 
                log('Call ended by user');
            } catch (e) {}
        }
        state.calling = false;
        document.getElementById('callBanner').classList.remove('show');
        setStatus('sCall', 'Ended', '');
        updateUI('idle');
        
        setTimeout(startListening, 1000);
    }

    // =====================================================
    // UI
    // =====================================================
    function updateUI(type, title, sub) {
        const status = document.getElementById('status');
        const icon = document.getElementById('icon');
        const titleEl = document.getElementById('title');
        const subEl = document.getElementById('sub');
        const widget = document.getElementById('widget');
        const dot = document.getElementById('wDot');
        const wText = document.getElementById('wText');

        status.className = 'status';
        widget.className = 'widget';
        dot.className = 'dot';

        if (type === 'listening') {
            status.classList.add('listening'); 
            widget.classList.add('listening'); 
            dot.classList.add('listening');
            icon.textContent = 'üëÇ';
            titleEl.textContent = title || 'Listening';
            subEl.innerHTML = sub || `Say <span class="badge">${CONFIG.wake}</span>`;
            wText.textContent = `Say "${CONFIG.wake}"`;
        } else if (type === 'active') {
            status.classList.add('active'); 
            widget.classList.add('active'); 
            dot.classList.add('active');
            icon.textContent = 'üó£Ô∏è';
            titleEl.textContent = title || 'Active';
            subEl.textContent = sub || 'Call in progress';
            wText.textContent = 'Call Active';
        } else {
            icon.textContent = 'üé§';
            titleEl.textContent = title || 'Ready';
            subEl.innerHTML = sub || `Say <span class="badge">${CONFIG.wake}</span>`;
            wText.textContent = 'Tap to start';
        }
    }

    function updateBtns(on) {
        document.getElementById('mainBtn').textContent = on ? '‚è∏Ô∏è Pause' : 'üëÇ Start';
        document.getElementById('cToggle').textContent = on ? '‚è∏Ô∏è Pause' : 'üëÇ Start';
    }

    function setStatus(id, text, cls) {
        const el = document.getElementById(id);
        if (el) { el.textContent = text; el.className = 'row-value ' + (cls || ''); }
    }

    function minimize() { document.body.classList.add('compact'); hideControls(); }
    function expand() { document.body.classList.remove('compact'); hideControls(); }
    function toggleControls(e) { e.stopPropagation(); document.getElementById('controls').classList.toggle('show'); }
    function hideControls() { document.getElementById('controls').classList.remove('show'); }
    document.addEventListener('click', hideControls);

    function toast(msg, type) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.className = 'toast show ' + (type || '');
        setTimeout(() => t.classList.remove('show'), 4000);
    }

    function testMic() { 
        if (!state.listening) startListening();
        toast(`Speak now - watch the Live Transcript`, 'success'); 
    }

    function playSound() {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g); g.connect(ctx.destination);
            
            // Two-tone chime
            o.frequency.setValueAtTime(523, ctx.currentTime);  // C5
            o.frequency.setValueAtTime(659, ctx.currentTime + 0.1);  // E5
            o.frequency.setValueAtTime(784, ctx.currentTime + 0.2);  // G5
            
            g.gain.setValueAtTime(0.2, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
            
            o.start(); 
            o.stop(ctx.currentTime + 0.4);
        } catch (e) {}
    }

    // Keep alive when tab switches
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && state.listening && !state.calling) {
            log('Tab visible - resuming');
            scheduleRestart(500);
        }
    });

    // Prevent sleep on mobile
    if ('wakeLock' in navigator) {
        navigator.wakeLock.request('screen').catch(() => {});
    }
    </script>
</body>
</html>
